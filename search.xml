<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>ArrayList源码学习</title>
      <link href="/2019/01/23/arraylist-yuan-ma-xue-xi/"/>
      <url>/2019/01/23/arraylist-yuan-ma-xue-xi/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>从这篇文章开始学习jdk相关源码，源码学习的目的是为了面试，了解原理，以及源码设计的独到之处。</p></blockquote><hr><h2 id="为什么要用ArrayList"><a href="#为什么要用ArrayList" class="headerlink" title="为什么要用ArrayList?"></a>为什么要用ArrayList?</h2><ol><li>数组:</li></ol><ul><li style="list-style: none"><input type="checkbox" checked> 在内存中划分出一块连续的地址空间用来进行元素的存储，由于直接操作内存，性能比集合类高一些。</li><li style="list-style: none"><input type="checkbox" checked> java中数组初始化时必须指定数组大小，并且不能更改数组的大小。</li></ul><ol start="2"><li>ArrayList:</li></ol><ul><li style="list-style: none"><input type="checkbox" checked> 动态数组，底层基于数组实现，查询修改快，插入删除慢。</li><li style="list-style: none"><input type="checkbox" checked> -容量可动态扩展，但是效率低，增加时判断是否扩容，删除指定下标的元素检查是否越界。</li></ul><hr><h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><p>源码分析基于1.8，首先来看继承和实现：<br>它继承于AbstractList，实现了List, RandomAccess, Cloneable, java.io.Serializable这些接口。</p><ul><li style="list-style: none"><input type="checkbox" checked> List，增删查改，遍历等功能</li><li style="list-style: none"><input type="checkbox" checked> RandomAccess，随机访问</li><li style="list-style: none"><input type="checkbox" checked> Serializable，这意味着ArrayList支持序列化，能通过序列化去传输。</li><li style="list-style: none"><input type="checkbox" checked> Cloneable，即覆盖了函数clone()，能被克隆<pre><code>      ArrayList&lt;Object&gt; list = new ArrayList&lt;&gt;();      list.add(&quot;123&quot;);      list.add(&quot;wmy&quot;);      Object object = list.clone();      System.out.println(object instanceof List);      List clone=(List)object;      list.forEach(t-&gt; System.out.println(t));      clone.forEach(t-&gt; System.out.println(&quot;*&quot;+t));</code></pre></li></ul><p>其次，来看成员变量：</p><pre><code>    //序列化id    private static final long serialVersionUID = 8683452581122892189L;    //默认容量    private static final int DEFAULT_CAPACITY = 10;    //空对象数组    private static final Object[] EMPTY_ELEMENTDATA = new Object[0];    //默认的空数组，无参构造时和扩容使用    private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = new Object[0];    //对象数组，数据真正放的位置    transient Object[] elementData;    //元素数量    private int size;    //最大容量    private static final int MAX_ARRAY_SIZE = 2147483639;</code></pre><p>接着来看构造函数：</p><ul><li style="list-style: none"><input type="checkbox" checked> 无参构造函数：</li></ul><pre><code> public ArrayList() {        this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;    }</code></pre><p>  此时的size为0，当第一次add元素时size变为10。</p><ul><li style="list-style: none"><input type="checkbox" checked> 带int类型参数的构造函数：</li></ul><pre><code> public ArrayList(int initialCapacity) {        if (initialCapacity &gt; 0) {            this.elementData = new Object[initialCapacity];        } else if (initialCapacity == 0) {            this.elementData = EMPTY_ELEMENTDATA;        } else {            throw new IllegalArgumentException(&quot;Illegal Capacity: &quot;+                                               initialCapacity);        }    }</code></pre><p>当传入参数大于0时，以用户传参初始化数组对象，等于0时，传入空数组，小于0时抛出异常。</p><ul><li style="list-style: none"><input type="checkbox" checked> 带Collection对象的构造函数：</li></ul><pre><code> public ArrayList(Collection&lt;? extends E&gt; c) {        elementData = c.toArray();        if ((size = elementData.length) != 0) {            // c.toArray might (incorrectly) not return Object[] (see 6260652)            if (elementData.getClass() != Object[].class)                elementData = Arrays.copyOf(elementData, size, Object[].class);        } else {            // replace with empty array.            this.elementData = EMPTY_ELEMENTDATA;        }    }</code></pre><p>查询方法：</p><pre><code>public E get(int index) {        rangeCheck(index);        return elementData(index);    }</code></pre><ul><li style="list-style: none"><input type="checkbox" checked> rangeCheck(index):查看指定位置的元素下标是否越界。</li></ul><pre><code>private void rangeCheck(int index) {        if (index &gt;= size)            throw new IndexOutOfBoundsException(outOfBoundsMsg(index));    }</code></pre><p>set方法：</p><pre><code> public E set(int index, E e) {            rangeCheck(index); //查看是否越界            checkForComodification();            E oldValue = ArrayList.this.elementData(offset + index);            ArrayList.this.elementData[offset + index] = e;            return oldValue;        }</code></pre><pre><code>private void checkForComodification() {            if (ArrayList.this.modCount != this.modCount)                throw new ConcurrentModificationException();}//线程A在遍历list过程的某个时候（此时expectedM//odCount = modCount=N），线程启动， //同时线程B增加一个元素，这是modCount的值发生//改变（modCount + 1 = N + 1）。 //线程A继续遍历执行next方法时， //通告checkForComodification方法发现expectedModCount = N ， 而modCount = N + 1，两者不等， //这时就抛出ConcurrentModificationException 异常，从而产生fail-fast机制。</code></pre><p>==注意：modCount为改变次数，一般有这个成员变量的集合都是线程不安全的==</p><p>add(E e)添加方法：</p><pre><code> public boolean add(E var1) {        this.ensureCapacityInternal(this.size + 1);        this.elementData[this.size++] = var1;        return true;    }</code></pre><ul><li style="list-style: none"><input type="checkbox" checked> ensureCapacityInternal():确认是否需要动态扩容</li></ul><pre><code> private void ensureCapacityInternal(int var1) {        if(this.elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) {             var1 = Math.max(10, var1); //当第一次添加元素时，为空数组对象，size=0        }        this.ensureExplicitCapacity(var1);    }</code></pre><ul><li style="list-style: none"><input type="checkbox" checked> ensureExplicitCapacity（）：动态扩容</li></ul><pre><code> private void ensureExplicitCapacity(int var1) {        ++this.modCount;        if(var1 - this.elementData.length &gt; 0) { //大于默认长度10就开始扩容            this.grow(var1);        }    }</code></pre><p>grow():</p><pre><code>private void grow(int var1) {        int var2 = this.elementData.length;        int var3 = var2 + (var2 &gt;&gt; 1); //1.5倍默认长度+1        if(var3 - var1 &lt; 0) {            var3 = var1;        }        if(var3 - 2147483639 &gt; 0) {            var3 = hugeCapacity(var1);        }        this.elementData = Arrays.copyOf(this.elementData, var3);    }</code></pre><p>add(int index,E e):指定位置添加元素</p><pre><code> public void add(int var1, E var2) {        this.rangeCheckForAdd(var1); //检查是否越界        this.ensureCapacityInternal(this.size + 1);//确认是否需要扩容        System.arraycopy(this.elementData, var1, this.elementData, var1 + 1, this.size - var1);        this.elementData[var1] = var2;        ++this.size;    }</code></pre><p>删除方法：remove(int index)</p><pre><code> public E remove(int var1) {        this.rangeCheck(var1);//越界检查        ++this.modCount;        Object var2 = this.elementData(var1);        int var3 = this.size - var1 - 1;        if(var3 &gt; 0) {            System.arraycopy(this.elementData, var1 + 1, this.elementData, var1, var3);        }        this.elementData[--this.size] = null;//清理用gc进行        return var2;    }</code></pre><p>删除方法：remove(Object e)</p><pre><code>public boolean remove(Object var1) {        int var2;        if(var1 == null) {            for(var2 = 0; var2 &lt; this.size; ++var2) {                if(this.elementData[var2] == null) {                    this.fastRemove(var2);                    return true;                }            }        } else {            for(var2 = 0; var2 &lt; this.size; ++var2) {                if(var1.equals(this.elementData[var2])) {                    this.fastRemove(var2);//删除当前下标元素，后面的元素往前移动一位                    return true;                }            }        }        return false;    }</code></pre><hr><h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><ol><li>快速-失败机制</li></ol><ul><li style="list-style: none"><input type="checkbox" checked> fail-fast 机制，即快速失败机制，是==java集合(Collection)中==的一种错误检测机制。当在迭代集合的过程中该集合在结构上发生改变的时候，就有可能会发生fail-fast，即抛出ConcurrentModificationException异常。</li><li style="list-style: none"><input type="checkbox" checked> fail-fast机制并不保证在不同步的修改下一定会抛出异常，它只是尽最大努力去抛出，所以这种机制一般仅用于检测bug。常与modCount联系在一起。</li><li style="list-style: none"><input type="checkbox" checked> 单线程环境下的fail-fast：</li></ul><pre><code>     public static void main(String[] args) {           List&lt;String&gt; list = new ArrayList&lt;&gt;();           for (int i = 0 ; i &lt; 10 ; i++ ) {                list.add(i + &quot;&quot;);           }           Iterator&lt;String&gt; iterator = list.iterator();           int i = 0 ;           while(iterator.hasNext()) {                if (i == 3) {                     list.remove(3);                }                System.out.println(iterator.next());                i ++;           }     }     //增强for循环foreach也会抛相同异常</code></pre><ul><li style="list-style: none"><input type="checkbox" checked> 多线程下的fail-fast:</li></ul><pre><code>public class FailFastTest {     public static List&lt;String&gt; list = new ArrayList&lt;&gt;();     private static class MyThread1 extends Thread {           @Override           public void run() {                Iterator&lt;String&gt; iterator = list.iterator();                while(iterator.hasNext()) {                     String s = iterator.next();                     System.out.println(this.getName() + &quot;:&quot; + s);                     try {                    Thread.sleep(1000);                } catch (InterruptedException e) {                    e.printStackTrace();                }                }                super.run();           }     }     private static class MyThread2 extends Thread {           int i = 0;           @Override           public void run() {                while (i &lt; 10) {                     System.out.println(&quot;thread2:&quot; + i);                     if (i == 2) {                           list.remove(i);                     }                     try {                    Thread.sleep(1000);                } catch (InterruptedException e) {                    e.printStackTrace();                }                     i ++;                }           }     }     public static void main(String[] args) {           for(int i = 0 ; i &lt; 10;i++){            list.add(i+&quot;&quot;);        }           MyThread1 thread1 = new MyThread1();           MyThread2 thread2 = new MyThread2();           thread1.setName(&quot;thread1&quot;);           thread2.setName(&quot;thread2&quot;);           thread1.start();           thread2.start();     }}</code></pre><ul><li style="list-style: none"><input type="checkbox" checked> 造成原因：注意以下方法：<br><code>`</code><pre><code>  final void checkForComodification() {      if (modCount != expectedModCount)          throw new ConcurrentModificationException();  }</code></pre></li></ul><p>int expectedModCount = modCount;</p><pre><code>从中我们知道modCount != expectedModCount才会异常，在一开始的时候，expectedModCount初始值默认等于modCount，为什么会出现modCount != expectedModCount，很明显expectedModCount在整个迭代过程除了一开始赋予初始值modCount外，并没有再发生改变，所以可能发生改变的就只有modCount，在前面关于ArrayList扩容机制的分析中，可以知道在ArrayList进行add，remove，clear等涉及到修改集合中的元素个数的操作时，modCount就会发生改变(modCount ++),所以当另一个线程(并发修改)或者同一个线程遍历过程中，调用相关方法使集合的个数发生改变，就会使modCount发生变化，这样在checkForComodification方法中就会抛出ConcurrentModificationException异常。- [x] 解决办法：利用iterator的remove方法，而不是集合类的remove:</code></pre><pre><code> public static void main(String[] args) {       List&lt;String&gt; list = new ArrayList&lt;&gt;();       for (int i = 0 ; i &lt; 10 ; i++ ) {            list.add(i + &quot;&quot;);       }       Iterator&lt;String&gt; iterator = list.iterator();       int i = 0 ;       while(iterator.hasNext()) {            if (i == 3) {                 iterator.remove(); //迭代器的remove()方法            }            System.out.println(iterator.next());            i ++;       } }</code></pre><pre><code>2. ArrayList如何正确删除元素？- [x] 正序删：</code></pre><p> ArrayList<integer> list = new ArrayList&lt;&gt;();<br>        list.add(1);<br>        list.add(5);<br>        list.add(5);<br>        list.add(5);<br>        list.add(8);<br>        list.add(10);<br>        for (int i = 0, size=list.size(); i &lt;size ; i++) {<br>            Integer item=list.get(i);<br>            if(item==5){<br>                list.remove(item);<br>                size–;<br>                i–;<br>            }</integer></p><pre><code>    }    list.forEach(t-&gt; System.out.println(t));</code></pre><pre><code>- [x] 倒序删：</code></pre><p>  ArrayList<integer> list = new ArrayList&lt;&gt;();<br>        list.add(1);<br>        list.add(5);<br>        list.add(5);<br>        list.add(5);<br>        list.add(8);<br>        list.add(10);<br>        for (int i = list.size()-1;i &gt;=0 ; i–) {<br>            Integer item=list.get(i);<br>            if(item==5){<br>                list.remove(item);<br>            }</integer></p><pre><code>    }    list.forEach(t-&gt; System.out.println(t));</code></pre><pre><code>- [x] iterator迭代器remove:</code></pre><p>ArrayList<integer> list = new ArrayList&lt;&gt;();<br>        list.add(1);<br>        list.add(5);<br>        list.add(5);<br>        list.add(5);<br>        list.add(8);<br>        list.add(10);<br>        Iterator<integer> iterator = list.iterator();<br>        while (iterator.hasNext()){<br>            Integer item=iterator.next();<br>            if(item==5){<br>                iterator.remove();<br>            }<br>        }</integer></integer></p><pre><code>    list.forEach(t-&gt; System.out.println(t));</code></pre><pre><code>3.list去重- [x] 基本数据类型（set去重）</code></pre><p> private static void  removeSame(){<br>        List list = new ArrayList&lt;&gt;();<br>        list.add(10);<br>        list.add(8);<br>        list.add(22);<br>        list.add(8);<br>        list.add(22);<br>        Set set = new HashSet();<br>        set.addAll(list);<br>        list.clear();<br>        list.addAll(set);<br>        list.forEach(t-&gt; System.out.println(t));</p><pre><code>}</code></pre><pre><code>set本来就是不重复的，其内部实现了hashmap,将元素作为hashmap的key,hashmap的key又不与序重复，至于原因我们学到hashmap的时候再细讲。- [x] 对象去重（需要重写equals和hashcode方法，再用set去重）</code></pre><p>package com.siteqi.study.base.jihe;</p><p>/**</p><ul><li>测试类<br>*</li><li>@author wangmaoyu</li><li><p>@create 2019-01-23 21:49<br>**/<br>public class Person {<br> private String name;<br> private Integer age;<br> private String sex;</p><p> public Person(String name, Integer age, String sex) {</p><pre><code> this.name = name; this.age = age; this.sex = sex;</code></pre><p> }</p><p> public String getName() {</p><pre><code> return name;</code></pre><p> }</p><p> public void setName(String name) {</p><pre><code> this.name = name;</code></pre><p> }</p><p> public Integer getAge() {</p><pre><code> return age;</code></pre><p> }</p><p> public void setAge(Integer age) {</p><pre><code> this.age = age;</code></pre><p> }</p><p> public String getSex() {</p><pre><code> return sex;</code></pre><p> }</p><p> public void setSex(String sex) {</p><pre><code> this.sex = sex;</code></pre><p> }</p><p> @Override<br> public boolean equals(Object obj) {<br>   if(this==obj){</p><pre><code>   return true;//地址相等</code></pre><p>   }<br>   if(obj==null){</p><pre><code>   return false;//非空性判断</code></pre><p>   }<br>   if(obj instanceof Person){</p><pre><code>   Person p= (Person) obj; //向下转型   if(this.name.equals(p.getName())&amp;&amp;this.age==p.age&amp;&amp;this.sex.equals(p.getSex())){ //判断对象相等的条件       return true;   }else{       return false;   }</code></pre><p>   }else{</p><pre><code>   return false;</code></pre><p>   }<br> }<br> //重写equals时必须重写hashcode，否则也无法判定对象是否相同，对象相等hash值一定相等<br> //为什么重写hashcode?调用的equals<br> @Override<br> public int hashCode() {</p><pre><code> //这里用31，模仿string的hashcode方法 int result = 17; result = 31 * result + (name == null ? 0 : name.hashCode()); result = 31 * result + (age == null ? 0 : age.hashCode()); result = 31 * result + (sex == null ? 0 : sex.hashCode()); return result;</code></pre><p> }</p><p> @Override<br> public String toString() {</p><pre><code> return this.name+&quot;:&quot;+age+&quot;:&quot;+this.sex;</code></pre><p> }<br>}<br><code>`</code><br>测试：</p></li></ul><pre><code>private static void  removeSameObject(){        List list = new ArrayList&lt;&gt;();        Person person1 = new Person(&quot;张三&quot;,24,&quot;男&quot;);        Person person2 = new Person(&quot;李四&quot;,25,&quot;女&quot;);        Person person3 = new Person(&quot;张三&quot;,24,&quot;男&quot;);        list.add(person1);        list.add(person2);        list.add(person3);        Set set = new HashSet();        set.addAll(list);        list.clear();        list.addAll(set);        list.forEach(t-&gt; System.out.println(t.toString()));    }</code></pre><ul><li style="list-style: none"><input type="checkbox" checked> 利用hashmap去重：这种方法只适用于属性全相同的对象</li></ul><pre><code>private static void  removeSameObjectByHashMap(){        List&lt;Person&gt; list = new ArrayList&lt;&gt;();        Person person1 = new Person(&quot;张三&quot;,24,&quot;男&quot;);        Person person2 = new Person(&quot;李四&quot;,25,&quot;女&quot;);        Person person3 = new Person(&quot;张三&quot;,24,&quot;男&quot;);        HashMap&lt;String, Person&gt; map = new HashMap&lt;&gt;();        map.put(person1.getName(),person1);        map.put(person2.getName(),person2);        map.put(person3.getName(),person3);        map.values().forEach(t-&gt;list.add(t));        list.forEach(t-&gt; System.out.println(t.toString()));    }</code></pre><ul><li style="list-style: none"><input type="checkbox" checked> 利用sream去重：还是要重写对象所属类的equals和hashcode方法</li></ul><pre><code>private static void removeSameObjectByStream() {        List&lt;Person&gt; list = new ArrayList&lt;&gt;();        Person person1 = new Person(&quot;张三&quot;,24,&quot;男&quot;);        Person person2 = new Person(&quot;李四&quot;,25,&quot;女&quot;);        Person person3 = new Person(&quot;张三&quot;,24,&quot;男&quot;);        list.add(person1);        list.add(person2);        list.add(person3);        list.stream().distinct().forEach(t-&gt; System.out.println(t.toString()));        //list.forEach(t -&gt; System.out.println(t.toString()));    }</code></pre><p>如果没有重写，可根据具体属性去去重：</p><pre><code>private static void removeSameObjectByStream() {        List&lt;Person&gt; list = new ArrayList&lt;&gt;();        Person person1 = new Person(&quot;张三&quot;,24,&quot;男&quot;);        Person person2 = new Person(&quot;李四&quot;,25,&quot;女&quot;);        Person person3 = new Person(&quot;张三&quot;,24,&quot;男&quot;);        list.add(person1);        list.add(person2);        list.add(person3);        StringBuffer str = new StringBuffer();        //根据具体属性去重，这里有两个属性去判断        List&lt;Person&gt; list1=list.stream().collect(                collectingAndThen(                        toCollection(() -&gt; new TreeSet&lt;&gt;(Comparator.comparing(o -&gt; o.getName() + &quot;;&quot; + o.getSex()))), ArrayList::new));        list1.forEach(t-&gt; System.out.println(t));    }</code></pre><ol start="4"><li>数组复制：Arrays.copyOf()和System.arraycopy()</li></ol><ul><li style="list-style: none"><input type="checkbox" checked> Arrays.copyOf()底层System.arraycopy()实现，System.arraycopy()实现浅复制（引用地址）</li></ul>]]></content>
      
      
      <categories>
          
          <category> java基础 </category>
          
          <category> 源码学习，集合 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> ArrayList </tag>
            
            <tag> JAVA8 </tag>
            
            <tag> 代码技巧 </tag>
            
            <tag> 哈希 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>从零开始搭建spring boot脚手架（六）</title>
      <link href="/2019/01/15/cong-ling-kai-shi-da-jian-spring-boot-jiao-shou-jia-liu/"/>
      <url>/2019/01/15/cong-ling-kai-shi-da-jian-spring-boot-jiao-shou-jia-liu/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>这篇文章主要讲在spring boot里面如何配置mybatis plus和代码生成工具。mybatis plus 相关api使用会在以后更新。</p></blockquote><hr><h2 id="spring-boot集成mybatis"><a href="#spring-boot集成mybatis" class="headerlink" title="spring boot集成mybatis"></a>spring boot集成mybatis</h2><pre><code>这里延续多数据源的数据库配置，即数据库连接请参考第五篇文章。</code></pre><p>1.pom引入：</p><pre><code>&lt;dependency&gt;    &lt;groupId&gt;com.baomidou&lt;/groupId&gt;    &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt;    &lt;version&gt;3.0.5&lt;/version&gt;    &lt;optional&gt;true&lt;/optional&gt;&lt;/dependency&gt;</code></pre><ol start="2"><li>application.yml配置如下：</li></ol><pre><code>mybatis-plus:  #xml扫描位置  mapper-locations: classpath*:mappers/*.xml  #实体类扫描位置  type-aliases-package: com.jinzonglv.web.model  global-config:    db-config:      #可选值：AUTO（数据库自增）、INPUT(自行输入)、ID_WORKER（分布式全局唯一ID）、UUID（32位UUID字符串）、ID_WORKER_STR（分布式全局唯一ID 字符串类型）      id-type: AUTO      #字段策略  default:&quot;默认&quot;,ignored:&quot;忽略判断&quot;,not_null:&quot;非 NULL 判断&quot;),not_empty:&quot;非空判断&quot;      field-strategy: ignored      db-type: mysql      #全局表前缀 tb_      table-prefix: tb_      #数据库大写下划线转换      #capital-mode: true      #逻辑删除配置（下面3个配置）      logic-delete-value: 1      logic-not-delete-value: 0    #是否自动刷新 Mapper 对应的 XML 文件,生产不建议开启    refresh: true  configuration:      map-underscore-to-camel-case: true      cache-enabled: false</code></pre><ol start="3"><li>mybatis plus mapper基础接口</li></ol><pre><code>public interface MpBaseMapper&lt;T&gt; extends BaseMapper&lt;T&gt; {}</code></pre><ol start="4"><li>mybatis plus mapper扫描配置类：</li></ol><pre><code>/** * mapper扫描 * * @author wangmaoyu * @create 2018-12-21 23:37 **/@Configurationpublic class MpMapperScannerConfig {    @Bean    public MapperScannerConfigurer mapperScannerConfigurer() {        MapperScannerConfigurer mapperScannerConfigurer = new MapperScannerConfigurer();        mapperScannerConfigurer.setSqlSessionFactoryBeanName(&quot;sqlSessionFactory&quot;);        mapperScannerConfigurer.setBasePackage(&quot;com.siteqi.web.mapper&quot;);//扫描该路径下的dao        Properties properties = new Properties();        properties.setProperty(&quot;mappers&quot;, &quot;com.siteqi.lib.MpBaseMapper&quot;);//通用mapper        properties.setProperty(&quot;notEmpty&quot;, &quot;false&quot;);        properties.setProperty(&quot;IDENTITY&quot;, &quot;MYSQL&quot;);        mapperScannerConfigurer.setProperties(properties);        return mapperScannerConfigurer;    }}</code></pre><ol start="5"><li>使用 </li></ol><pre><code>public List&lt;MovieVO&gt; getMovies() {        DbContextHolder.setDb(DbTypeEnum.master);        return movieMapper.selectList(new QueryWrapper&lt;Movie&gt;().lambda().eq(Movie::getPx,&quot;1080p&quot;)).stream().map(MovieVO::new).collect(Collectors.toList());    }</code></pre><p>效果:<br> <img src="/2019/01/15/cong-ling-kai-shi-da-jian-spring-boot-jiao-shou-jia-liu/6-1.png" alt="image"></p><hr><h2 id="自动生成工具"><a href="#自动生成工具" class="headerlink" title="自动生成工具"></a>自动生成工具</h2><p>pom依赖引入：</p><pre><code>&lt;dependency&gt;    &lt;groupId&gt;com.baomidou&lt;/groupId&gt;    &lt;artifactId&gt;mybatis-plus-generator&lt;/artifactId&gt;    &lt;version&gt;3.0.5&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;org.apache.velocity&lt;/groupId&gt;    &lt;artifactId&gt;velocity-engine-core&lt;/artifactId&gt;    &lt;version&gt;2.0&lt;/version&gt;    &lt;/dependency&gt;</code></pre><p>工具类：</p><pre><code>package com.siteqi.util;import com.baomidou.mybatisplus.annotation.DbType;import com.baomidou.mybatisplus.generator.AutoGenerator;import com.baomidou.mybatisplus.generator.config.*;import com.baomidou.mybatisplus.generator.config.rules.NamingStrategy;import com.baomidou.mybatisplus.generator.engine.FreemarkerTemplateEngine;import com.siteqi.enums.DbTypeEnum;import java.util.*;/** * MP代码生成器 * * @author wangmaoyu * @create 2019-01-14 20:13 **/public class CodeGenerator {    public static  void  generate(String dbUrl){        System.out.println(&quot;请输入需要生成的表明(每个表以‘,’号结尾：&quot;);        Scanner scanner = new Scanner(System.in);        String tableNames=null;        if (scanner.hasNext()){            tableNames=scanner.next();        }        List&lt;String&gt; tables=new ArrayList&lt;&gt;();        /*String[] tablesArr=tableNames.split(&quot;,&quot;);        tables.addAll(Arrays.asList(tablesArr));*/        Collections.addAll(tables, tableNames.split(&quot;,&quot;));        System.out.println(&quot;你输入了以下表名：&quot;);        tables.stream().forEach(t-&gt; System.out.println(t));        AutoGenerator autoGenerator = new AutoGenerator();        //全局配置        GlobalConfig globalConfig = new GlobalConfig();        globalConfig.setOutputDir(&quot;G://dataZone/codeGenerate&quot;);        globalConfig.setFileOverride(true);        globalConfig.setActiveRecord(true);//不需要ActiveRecord特性的请改为false        globalConfig.setEnableCache(false);//XML二级缓存        globalConfig.setBaseResultMap(true);//XML ResultMap        globalConfig.setBaseColumnList(false);//XML columList        globalConfig.setAuthor(&quot;wangmaoyu&quot;);//作者        //自定义文件命名，注意%s 会自动填充表实体属性        globalConfig.setControllerName(&quot;%sController&quot;);        globalConfig.setServiceName(&quot;%sService&quot;);        globalConfig.setServiceImplName(&quot;%sServiceImpl&quot;);        globalConfig.setMapperName(&quot;%sMapper&quot;);        globalConfig.setXmlName(&quot;%sMapper&quot;);        autoGenerator.setGlobalConfig(globalConfig);        //数据源配置        DataSourceConfig dataSourceConfig = new DataSourceConfig();        dataSourceConfig.setDbType(DbType.MYSQL);        dataSourceConfig.setDriverName(&quot;com.mysql.jdbc.Driver&quot;);        dataSourceConfig.setUsername(&quot;root&quot;);        dataSourceConfig.setPassword(&quot;root1&quot;);        dataSourceConfig.setUrl(dbUrl);        autoGenerator.setDataSource(dataSourceConfig);        //策略配置        StrategyConfig strategyConfig = new StrategyConfig();        strategyConfig.setTablePrefix(&quot;tb_&quot;);//此处可以修改您的表前缀        strategyConfig.setNaming(NamingStrategy.underline_to_camel);//表名生成策略        strategyConfig.setColumnNaming(NamingStrategy.underline_to_camel);//字段生成策略        strategyConfig.setEntityLombokModel(true);        strategyConfig.setRestControllerStyle(true);        strategyConfig.setInclude(tables.toArray(new String[tables.size()]));//需要生成的表        strategyConfig.setSuperControllerClass(null);        strategyConfig.setSuperServiceClass(null);        strategyConfig.setSuperServiceImplClass(null);        strategyConfig.setSuperMapperClass(null);        autoGenerator.setStrategy(strategyConfig);        //包配置        PackageConfig packageConfig = new PackageConfig();        packageConfig.setParent(&quot;com.siteqi.web&quot;);        packageConfig.setController(&quot;controller&quot;);        packageConfig.setService(&quot;service&quot;);        packageConfig.setServiceImpl(&quot;serviceImpl&quot;);        packageConfig.setMapper(&quot;mapper&quot;);        packageConfig.setEntity(&quot;model&quot;);        packageConfig.setXml(&quot;xml&quot;);        autoGenerator.setPackageInfo(packageConfig);        TemplateConfig templateConfig = new TemplateConfig();        templateConfig.setXml(null);        autoGenerator.setTemplate(templateConfig);        autoGenerator.setTemplateEngine(new FreemarkerTemplateEngine());        autoGenerator.execute();    }    public static void main(String[] args) {        CodeGenerator.generate(DbTypeEnum.master_url.getValue());    }}</code></pre>]]></content>
      
      
      <categories>
          
          <category> spring boot </category>
          
          <category> 微服务 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 脚手架 </tag>
            
            <tag> 多数据源 </tag>
            
            <tag> Mybatis Plus </tag>
            
            <tag> 自动生成 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>从零开始搭建spring boot脚手架（六）</title>
      <link href="/2019/01/15/cong-ling-kai-shi-da-jian-spring-boot-jiao-shou-jia-liu/"/>
      <url>/2019/01/15/cong-ling-kai-shi-da-jian-spring-boot-jiao-shou-jia-liu/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>这篇文章主要讲在spring boot里面如何配置mybatis plus和代码生成工具。mybatis plus 相关api使用会在以后更新。</p></blockquote><hr><h2 id="spring-boot集成mybatis"><a href="#spring-boot集成mybatis" class="headerlink" title="spring boot集成mybatis"></a>spring boot集成mybatis</h2><pre><code>这里延续多数据源的数据库配置，即数据库连接请参考第五篇文章。</code></pre><p>1.pom引入：</p><pre><code>&lt;dependency&gt;    &lt;groupId&gt;com.baomidou&lt;/groupId&gt;    &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt;    &lt;version&gt;3.0.5&lt;/version&gt;    &lt;optional&gt;true&lt;/optional&gt;&lt;/dependency&gt;</code></pre><ol start="2"><li>application.yml配置如下：</li></ol><pre><code>mybatis-plus:  #xml扫描位置  mapper-locations: classpath*:mappers/*.xml  #实体类扫描位置  type-aliases-package: com.jinzonglv.web.model  global-config:    db-config:      #可选值：AUTO（数据库自增）、INPUT(自行输入)、ID_WORKER（分布式全局唯一ID）、UUID（32位UUID字符串）、ID_WORKER_STR（分布式全局唯一ID 字符串类型）      id-type: AUTO      #字段策略  default:&quot;默认&quot;,ignored:&quot;忽略判断&quot;,not_null:&quot;非 NULL 判断&quot;),not_empty:&quot;非空判断&quot;      field-strategy: ignored      db-type: mysql      #全局表前缀 tb_      table-prefix: tb_      #数据库大写下划线转换      #capital-mode: true      #逻辑删除配置（下面3个配置）      logic-delete-value: 1      logic-not-delete-value: 0    #是否自动刷新 Mapper 对应的 XML 文件,生产不建议开启    refresh: true  configuration:      map-underscore-to-camel-case: true      cache-enabled: false</code></pre><ol start="3"><li>mybatis plus mapper基础接口</li></ol><pre><code>public interface MpBaseMapper&lt;T&gt; extends BaseMapper&lt;T&gt; {}</code></pre><ol start="4"><li>mybatis plus mapper扫描配置类：</li></ol><pre><code>/** * mapper扫描 * * @author wangmaoyu * @create 2018-12-21 23:37 **/@Configurationpublic class MpMapperScannerConfig {    @Bean    public MapperScannerConfigurer mapperScannerConfigurer() {        MapperScannerConfigurer mapperScannerConfigurer = new MapperScannerConfigurer();        mapperScannerConfigurer.setSqlSessionFactoryBeanName(&quot;sqlSessionFactory&quot;);        mapperScannerConfigurer.setBasePackage(&quot;com.siteqi.web.mapper&quot;);//扫描该路径下的dao        Properties properties = new Properties();        properties.setProperty(&quot;mappers&quot;, &quot;com.siteqi.lib.MpBaseMapper&quot;);//通用mapper        properties.setProperty(&quot;notEmpty&quot;, &quot;false&quot;);        properties.setProperty(&quot;IDENTITY&quot;, &quot;MYSQL&quot;);        mapperScannerConfigurer.setProperties(properties);        return mapperScannerConfigurer;    }}</code></pre><ol start="5"><li>使用 </li></ol><pre><code>public List&lt;MovieVO&gt; getMovies() {        DbContextHolder.setDb(DbTypeEnum.master);        return movieMapper.selectList(new QueryWrapper&lt;Movie&gt;().lambda().eq(Movie::getPx,&quot;1080p&quot;)).stream().map(MovieVO::new).collect(Collectors.toList());    }</code></pre><p>效果:<br> <img src="/2019/01/15/cong-ling-kai-shi-da-jian-spring-boot-jiao-shou-jia-liu/6-1.png" alt="image"></p><hr><h2 id="自动生成工具"><a href="#自动生成工具" class="headerlink" title="自动生成工具"></a>自动生成工具</h2><p>pom依赖引入：</p><pre><code>&lt;dependency&gt;    &lt;groupId&gt;com.baomidou&lt;/groupId&gt;    &lt;artifactId&gt;mybatis-plus-generator&lt;/artifactId&gt;    &lt;version&gt;3.0.5&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;org.apache.velocity&lt;/groupId&gt;    &lt;artifactId&gt;velocity-engine-core&lt;/artifactId&gt;    &lt;version&gt;2.0&lt;/version&gt;    &lt;/dependency&gt;</code></pre><p>工具类：</p><pre><code>package com.siteqi.util;import com.baomidou.mybatisplus.annotation.DbType;import com.baomidou.mybatisplus.generator.AutoGenerator;import com.baomidou.mybatisplus.generator.config.*;import com.baomidou.mybatisplus.generator.config.rules.NamingStrategy;import com.baomidou.mybatisplus.generator.engine.FreemarkerTemplateEngine;import com.siteqi.enums.DbTypeEnum;import java.util.*;/** * MP代码生成器 * * @author wangmaoyu * @create 2019-01-14 20:13 **/public class CodeGenerator {    public static  void  generate(String dbUrl){        System.out.println(&quot;请输入需要生成的表明(每个表以‘,’号结尾：&quot;);        Scanner scanner = new Scanner(System.in);        String tableNames=null;        if (scanner.hasNext()){            tableNames=scanner.next();        }        List&lt;String&gt; tables=new ArrayList&lt;&gt;();        /*String[] tablesArr=tableNames.split(&quot;,&quot;);        tables.addAll(Arrays.asList(tablesArr));*/        Collections.addAll(tables, tableNames.split(&quot;,&quot;));        System.out.println(&quot;你输入了以下表名：&quot;);        tables.stream().forEach(t-&gt; System.out.println(t));        AutoGenerator autoGenerator = new AutoGenerator();        //全局配置        GlobalConfig globalConfig = new GlobalConfig();        globalConfig.setOutputDir(&quot;G://dataZone/codeGenerate&quot;);        globalConfig.setFileOverride(true);        globalConfig.setActiveRecord(true);//不需要ActiveRecord特性的请改为false        globalConfig.setEnableCache(false);//XML二级缓存        globalConfig.setBaseResultMap(true);//XML ResultMap        globalConfig.setBaseColumnList(false);//XML columList        globalConfig.setAuthor(&quot;wangmaoyu&quot;);//作者        //自定义文件命名，注意%s 会自动填充表实体属性        globalConfig.setControllerName(&quot;%sController&quot;);        globalConfig.setServiceName(&quot;%sService&quot;);        globalConfig.setServiceImplName(&quot;%sServiceImpl&quot;);        globalConfig.setMapperName(&quot;%sMapper&quot;);        globalConfig.setXmlName(&quot;%sMapper&quot;);        autoGenerator.setGlobalConfig(globalConfig);        //数据源配置        DataSourceConfig dataSourceConfig = new DataSourceConfig();        dataSourceConfig.setDbType(DbType.MYSQL);        dataSourceConfig.setDriverName(&quot;com.mysql.jdbc.Driver&quot;);        dataSourceConfig.setUsername(&quot;root&quot;);        dataSourceConfig.setPassword(&quot;root1&quot;);        dataSourceConfig.setUrl(dbUrl);        autoGenerator.setDataSource(dataSourceConfig);        //策略配置        StrategyConfig strategyConfig = new StrategyConfig();        strategyConfig.setTablePrefix(&quot;tb_&quot;);//此处可以修改您的表前缀        strategyConfig.setNaming(NamingStrategy.underline_to_camel);//表名生成策略        strategyConfig.setColumnNaming(NamingStrategy.underline_to_camel);//字段生成策略        strategyConfig.setEntityLombokModel(true);        strategyConfig.setRestControllerStyle(true);        strategyConfig.setInclude(tables.toArray(new String[tables.size()]));//需要生成的表        strategyConfig.setSuperControllerClass(null);        strategyConfig.setSuperServiceClass(null);        strategyConfig.setSuperServiceImplClass(null);        strategyConfig.setSuperMapperClass(null);        autoGenerator.setStrategy(strategyConfig);        //包配置        PackageConfig packageConfig = new PackageConfig();        packageConfig.setParent(&quot;com.siteqi.web&quot;);        packageConfig.setController(&quot;controller&quot;);        packageConfig.setService(&quot;service&quot;);        packageConfig.setServiceImpl(&quot;serviceImpl&quot;);        packageConfig.setMapper(&quot;mapper&quot;);        packageConfig.setEntity(&quot;model&quot;);        packageConfig.setXml(&quot;xml&quot;);        autoGenerator.setPackageInfo(packageConfig);        TemplateConfig templateConfig = new TemplateConfig();        templateConfig.setXml(null);        autoGenerator.setTemplate(templateConfig);        autoGenerator.setTemplateEngine(new FreemarkerTemplateEngine());        autoGenerator.execute();    }    public static void main(String[] args) {        CodeGenerator.generate(DbTypeEnum.master_url.getValue());    }}</code></pre>]]></content>
      
      
      <categories>
          
          <category> spring boot </category>
          
          <category> 微服务 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 脚手架 </tag>
            
            <tag> 多数据源 </tag>
            
            <tag> Mybatis Plus </tag>
            
            <tag> 自动生成 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>从零开始搭建spring boot脚手架（五）</title>
      <link href="/2019/01/08/cong-ling-kai-shi-da-jian-spring-boot-jiao-shou-jia-wu/"/>
      <url>/2019/01/08/cong-ling-kai-shi-da-jian-spring-boot-jiao-shou-jia-wu/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>这篇博客主要讲在spring boot如何配置多数据源，这里的多数据源主要是读写分离，至于读写分离的内容有时间慢慢研究。主要通过以下内容配置：</p></blockquote><hr><h2 id="application-yml配置数据源连接"><a href="#application-yml配置数据源连接" class="headerlink" title="application.yml配置数据源连接"></a>application.yml配置数据源连接</h2><pre><code>spring:  datasource:    type: com.alibaba.druid.pool.DruidDataSource    druid:      max-active: 80      initialSize: 5      minIdle: 8      maxWait: 60000      timeBetweenEvictionRunsMillis: 60000      minEvictableIdleTimeMillis: 300000      validationQuery: SELECT &#39;x&#39;      testWhileIdle: true      testOnBorrow: false      testOnReturn: false      poolPreparedStatements: false      maxPoolPreparedStatementPerConnectionSize: 20      removeAbandoned: true      removeAbandonedTimeoutMillis: 20000      logAbandoned: true      logDifferentThread: true      filters: wall,stat      connectionProperties:  druid.stat.mergeSql=true;druid.stat.logSlowSql=true;druid.stat.slowSqlMillis=3000      useGlobalDataSourceStat: true    master:      type: com.alibaba.druid.pool.DruidDataSource      driver-class-name: com.mysql.jdbc.Driver      #spring boot 2.0默认使用hariki数据库连接池，所以配置url使用jdbc-url      url: jdbc:mysql://106.12.25.134:3306/practice?useUnicode=true&amp;characterEncoding=utf-8&amp;useSSL=false      username: 用户名      password: 密码    slave:      type: com.alibaba.druid.pool.DruidDataSource      driver-class-name: com.mysql.jdbc.Driver      url: jdbc:mysql://106.12.25.134:3306/blog?useUnicode=true&amp;characterEncoding=utf-8&amp;useSSL=false      username: 用户名      password: 密码</code></pre><p>==注意：spring boot 2.0默认的数据库连接池是hariki==</p><hr><h2 id="DBTypeEnum"><a href="#DBTypeEnum" class="headerlink" title="DBTypeEnum"></a>DBTypeEnum</h2><p>用一个枚举列出所有数据源，用于后面的配置。</p><pre><code>/** * db数据源名称 * * @author wangmaoyu * @create 2018-12-27 23:03 **/public enum DbTypeEnum {    master(&quot;dataSource_master&quot;),slave(&quot;dataSource_slave&quot;);    private String value;    public String getValue() {        return value;    }    DbTypeEnum(String value) {        this.value = value;    }}</code></pre><hr><h2 id="DbContextHolder"><a href="#DbContextHolder" class="headerlink" title="DbContextHolder"></a>DbContextHolder</h2><p>DbContextHolder当前线程所持有的数据源。</p><pre><code>/** * 保存一个线程安全的DatabaseType容器 * * @author wangmaoyu * @create 2018-12-25 23:57 **/@Slf4jpublic class DbContextHolder {    private static final ThreadLocal&lt;String&gt; contextHolder = new ThreadLocal&lt;&gt;();    /**     * 设置数据源     * @param dbTypeEnum     */    public static void setDb(DbTypeEnum dbTypeEnum){        log.debug(&quot;切换到{}数据源&quot;, dbTypeEnum.getValue());        contextHolder.set(dbTypeEnum.getValue());    }    /**     * 取得数据源     * @return     */    public static  String getDb(){        return contextHolder.get();    }    /**     * 清除数据源     */    public static void clearDb(){        contextHolder.remove();    }}</code></pre><hr><h2 id="DynamicDataSource"><a href="#DynamicDataSource" class="headerlink" title="DynamicDataSource"></a>DynamicDataSource</h2><p>DynamicDataSource继承AbstractRoutingDataSource，并重写其中的方法determineCurrentLookupKey()，在该方法中使用DbContextHolder获取当前线程的数据源。</p><pre><code>/** * 动态数据源 * * @author wangmaoyu * @create 2018-12-25 23:54 **/@Slf4jpublic class DynamicDataSource extends AbstractRoutingDataSource {    @Override    protected Object determineCurrentLookupKey() {        log.debug(&quot;数据源为{}&quot;, DbContextHolder.getDb());        return DbContextHolder.getDb();    }}</code></pre><hr><h2 id="DBConfig"><a href="#DBConfig" class="headerlink" title="DBConfig"></a>DBConfig</h2><p>DBConfig多数据源配置</p><pre><code>/** * 多数据源配置 * * @author wangmaoyu * @create 2018-12-25 23:45 **/@Configuration//@EnableConfigurationProperties(value = {MasterDBProperties.class,SlaveDBProperties.class})public class DBConfig   {    /**     * 动态数据源     * @return     */    @Bean    @Primary    public DynamicDataSource dynamicDataSource() {        DynamicDataSource dynamicDataSource=new DynamicDataSource();        dynamicDataSource.setTargetDataSources(ImmutableMap.of(&quot;dataSource_master&quot;,datasourceMaster(),&quot;dataSource_slave&quot;,datasourceSlave()));        dynamicDataSource.setDefaultTargetDataSource(datasourceMaster());        return  dynamicDataSource;    }    /**     * 主数据库     * @return     */    @Bean(&quot;datasourceMaster&quot;)    @ConfigurationProperties(prefix = &quot;spring.datasource.master&quot;)    public DataSource datasourceMaster(){         return DruidDataSourceBuilder.create().build(); //druid数据库        //return DataSourceBuilder.create().build(); //默认数据库 注意配置文件url    }    /**     * 副数据库     * @return     */    @Bean(&quot;datasourceSlave&quot;)    @ConfigurationProperties(prefix = &quot;spring.datasource.slave&quot;)    public DataSource datasourceSlave() {        return DruidDataSourceBuilder.create().build();        //return DataSourceBuilder.create().build();    }</code></pre><p>==注意：@EnableConfigurationProperties这个注解的作用是将@Configuration注解的类能够@autowired注入其它类里==</p><hr><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><pre><code>public List&lt;Student&gt; getStudents() {        DbContextHolder.clearDb();        DbContextHolder.setDb(DbTypeEnum.slave);        System.out.println(&quot;******&quot; + DbContextHolder.getDb());        return studentMapper.selectAll();    }</code></pre><p>只需要DbContextHolder.setDb(DbTypeEnum.slave);就能切换当前线程的数据源</p><hr><h2 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h2><p>注意：以上这种方式配置的多数据源不支持同时往两个库的两张表里更新数据的事务，如果要实现这种情况还需另外考虑，可参考xa分布式事务。</p>]]></content>
      
      
      <categories>
          
          <category> spring boot </category>
          
          <category> 微服务 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 脚手架 </tag>
            
            <tag> 多数据源 </tag>
            
            <tag> 读写分离 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>从零开始搭建spring boot脚手架（四）</title>
      <link href="/2018/12/24/cong-ling-kai-shi-da-jian-spring-boot-jiao-shou-jia-si/"/>
      <url>/2018/12/24/cong-ling-kai-shi-da-jian-spring-boot-jiao-shou-jia-si/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>这篇文章主要讲如何用spring boot如何集成mybatis，同时生成通用mapper,省去了xml,do，mapper接口的创建。</p></blockquote><hr><h2 id="需要引入的依赖"><a href="#需要引入的依赖" class="headerlink" title="需要引入的依赖"></a>需要引入的依赖</h2><pre><code>&lt;dependency&gt;    &lt;groupId&gt;tk.mybatis&lt;/groupId&gt;    &lt;artifactId&gt;mapper-spring-boot-starter&lt;/artifactId&gt; &lt;!-- 引入spring boot需要的mybatis第三方包 ，这里为了集成通用mapper集成tk的--&gt;    &lt;version&gt;${mapper.sb.version}&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;tk.mybatis&lt;/groupId&gt;    &lt;artifactId&gt;mapper&lt;/artifactId&gt;    &lt;version&gt;${mapper.version}&lt;/version&gt;&lt;/dependency&gt;&lt;!--mybatis通用mapper插件配置--&gt;            &lt;plugin&gt;                &lt;groupId&gt;org.mybatis.generator&lt;/groupId&gt;                &lt;artifactId&gt;mybatis-generator-maven-plugin&lt;/artifactId&gt;                &lt;version&gt;1.3.2&lt;/version&gt;                &lt;configuration&gt;                    &lt;configurationFile&gt;${basedir}/src/main/resources/generator/generatorConfig.xml&lt;/configurationFile&gt;                    &lt;overwrite&gt;true&lt;/overwrite&gt;                    &lt;verbose&gt;true&lt;/verbose&gt;                &lt;/configuration&gt;                &lt;dependencies&gt;                    &lt;dependency&gt;                        &lt;groupId&gt;mysql&lt;/groupId&gt;                        &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;                        &lt;version&gt;${mysql.version}&lt;/version&gt;                    &lt;/dependency&gt;                    &lt;dependency&gt;                        &lt;groupId&gt;tk.mybatis&lt;/groupId&gt;                        &lt;artifactId&gt;mapper&lt;/artifactId&gt;                        &lt;version&gt;${mapper.version}&lt;/version&gt;                    &lt;/dependency&gt;                &lt;/dependencies&gt;            &lt;/plugin&gt;            &lt;!--版本--&gt;    &lt;mapper.sb.version&gt;2.1.2&lt;/mapper.sb.version&gt;        &lt;mapper.version&gt;3.4.2&lt;/mapper.version&gt;        &lt;!--  MyBatis Generator后面的generatorConfig.xml读取  --&gt;        &lt;!--  Java接口和实体类  --&gt;        &lt;targetJavaProject&gt;${basedir}/src/main/java&lt;/targetJavaProject&gt;        &lt;targetMapperPackage&gt;com.siteqi.web.mapper&lt;/targetMapperPackage&gt;        &lt;targetModelPackage&gt;com.siteqi.web.model&lt;/targetModelPackage&gt;        &lt;!--  XML生成路径  --&gt;        &lt;targetResourcesProject&gt;${basedir}/src/main/resources&lt;/targetResourcesProject&gt;        &lt;targetXMLPackage&gt;mappers&lt;/targetXMLPackage&gt;</code></pre><hr><h2 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h2><pre><code>需要配置一个数据库连接池配置文件给generatorConfig.xml使用如图所示：![image](20181224233015.png)config.properties配置如下：</code></pre><pre><code># 数据库配置jdbc.driverClass = com.mysql.jdbc.Driverjdbc.url = jdbc:mysql://106.12.25.134:3306/practicejdbc.user = 用户名jdbc.password = 密码#c3p0jdbc.maxPoolSize=50jdbc.minPoolSize=10jdbc.maxStatements=100jdbc.testConnection=true# 通用Mapper配置（插件+基础mapper接口）mapper.plugin = tk.mybatis.mapper.generator.MapperPluginmapper.Mapper =com.siteqi.lib.MyBaseMapper</code></pre><p>generatorConfig.xml配置如下：</p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE generatorConfiguration        PUBLIC &quot;-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN&quot;        &quot;http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd&quot;&gt;&lt;generatorConfiguration&gt;    &lt;!--读取数据库连接池-&gt;    &lt;properties resource=&quot;generator/config.properties&quot;/&gt;     &lt;context id=&quot;Mysql&quot; targetRuntime=&quot;MyBatis3Simple&quot; defaultModelType=&quot;flat&quot;&gt;        &lt;!--配置是否使用通用 Mapper 自带的注释扩展，默认 true--&gt;        &lt;!--&lt;property name=&quot;useMapperCommentGenerator&quot; value=&quot;false&quot;/&gt;--&gt;        &lt;property name=&quot;javaFileEncoding&quot; value=&quot;UTF-8&quot;/&gt;        &lt;property name=&quot;beginningDelimiter&quot; value=&quot;`&quot;/&gt;        &lt;property name=&quot;endingDelimiter&quot; value=&quot;`&quot;/&gt;        &lt;!--通用 Mapper 插件，生成的mapper接口继承通用接口--&gt;        &lt;plugin type=&quot;${mapper.plugin}&quot;&gt;            &lt;property name=&quot;mappers&quot; value=&quot;${mapper.Mapper}&quot;/&gt;        &lt;/plugin&gt;        &lt;jdbcConnection driverClass=&quot;${jdbc.driverClass}&quot; connectionURL=&quot;${jdbc.url}&quot; userId=&quot;${jdbc.user}&quot; password=&quot;${jdbc.password}&quot;/&gt;        &lt;!--确定model,mapper.xml,mapper接口的位置--&gt;        &lt;javaModelGenerator targetPackage=&quot;${targetModelPackage}&quot; targetProject=&quot;${targetJavaProject}&quot;/&gt;        &lt;sqlMapGenerator targetPackage=&quot;${targetXMLPackage}&quot; targetProject=&quot;${targetResourcesProject}&quot;/&gt;        &lt;javaClientGenerator targetPackage=&quot;${targetMapperPackage}&quot; targetProject=&quot;${targetJavaProject}&quot; type=&quot;XMLMAPPER&quot; /&gt;        &lt;!--&lt;table tableName=&quot;%&quot; &gt; 生成所有表--&gt;        &lt;!--domainObjectName生成实体别名--&gt;        &lt;table tableName=&quot;tb_movie&quot; domainObjectName=&quot;Movie&quot;&gt;            &lt;generatedKey column=&quot;id&quot; sqlStatement=&quot;Mysql&quot; identity=&quot;true&quot;/&gt;        &lt;/table&gt;    &lt;/context&gt;&lt;/generatorConfiguration&gt;</code></pre><p>application.yml配置如下：</p><pre><code>mybatis: configuration:    #驼峰规则    map-underscore-to-camel-case: true    #生成的mapper.xml位置 mapper-locations:  classpath*:mappers/*.xml</code></pre><p>基础mapper接口：</p><pre><code>public interface MyBaseMapper&lt;T&gt; extends BaseMapper&lt;T&gt; {}</code></pre><hr><h2 id="代码生成"><a href="#代码生成" class="headerlink" title="代码生成"></a>代码生成</h2><p>因为配置自动生成的maven插件，可直接运行其生成相应代码和xml<br>如下图：<br><img src="/2018/12/24/cong-ling-kai-shi-da-jian-spring-boot-jiao-shou-jia-si/20181224234302.png" alt="image"><br>生成代码如下图：<br><img src="/2018/12/24/cong-ling-kai-shi-da-jian-spring-boot-jiao-shou-jia-si/20181224234609.png" alt="image"></p><hr><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>测试代码：</p><pre><code>@RestController@RequestMapping(&quot;/movie&quot;)public class MovieController {    @Autowired    private MovieService movieService;    @GetMapping(&quot;/list&quot;)    public List&lt;MovieVO&gt; getMovies(){        List&lt;MovieVO&gt; movieVOList=movieService.getMovies();        return movieVOList;    }}</code></pre><pre><code>@Servicepublic class MovieServiceImpl implements MovieService {    @Autowired    private MovieMapper movieMapper;    @Override    public List&lt;MovieVO&gt; getMovies() {        return movieMapper.selectAll().stream().map(MovieVO::new).collect(Collectors.toList());    }}</code></pre><p>测试效果如图：<br><img src="/2018/12/24/cong-ling-kai-shi-da-jian-spring-boot-jiao-shou-jia-si/20181224235207.png" alt="image"></p>]]></content>
      
      
      <categories>
          
          <category> spring boot </category>
          
          <category> 微服务 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 脚手架 </tag>
            
            <tag> 自动生成 </tag>
            
            <tag> mybatis </tag>
            
            <tag> 通用mapper </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>从零开始搭建spring boot脚手架（三）</title>
      <link href="/2018/12/17/cong-ling-kai-shi-da-jian-spring-boot-jiao-shou-jia-san/"/>
      <url>/2018/12/17/cong-ling-kai-shi-da-jian-spring-boot-jiao-shou-jia-san/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>本篇主要讲述如何使用druid连接mysql，并用jdbcTemplate做测试。</p></blockquote><hr><h2 id="druid配置"><a href="#druid配置" class="headerlink" title="druid配置"></a>druid配置</h2><p>application.yml配置文件如下：</p><pre><code>spring:  datasource:    type: com.alibaba.druid.pool.DruidDataSource    druid:      driver-class-name: com.mysql.jdbc.Driver      url: jdbc:mysql://106.12.25.134:3306/practice?useUnicode=true&amp;characterEncoding=utf-8&amp;useSSL=false      username: 用户名      password: 密码      max-active: 80      initialSize: 5      minIdle: 8      maxWait: 60000      timeBetweenEvictionRunsMillis: 60000      minEvictableIdleTimeMillis: 300000      validationQuery: SELECT &#39;x&#39;      testWhileIdle: true      testOnBorrow: false      testOnReturn: false      poolPreparedStatements: false      maxPoolPreparedStatementPerConnectionSize: 20      removeAbandoned: true      removeAbandonedTimeoutMillis: 20000      logAbandoned: true      logDifferentThread: true      filters: wall,stat      connectionProperties:  druid.stat.mergeSql=true;druid.stat.logSlowSql=true;druid.stat.slowSqlMillis=3000      useGlobalDataSourceStat: true</code></pre><p>配置文件读取类：</p><pre><code>@ConfigurationProperties(prefix =&quot;spring.datasource.druid&quot;)@Datapublic class DruidProperties {    private String driverClassName;    private String url;    private String username;    private String password;    private int initialSize;    private int minIdle;    private int maxActive;    private long maxWait;    private long timeBetweenEvictionRunsMillis;    private long minEvictableIdleTimeMillis;    private String validationQuery;    private boolean testWhileIdle;    private boolean testOnBorrow;    private boolean testOnReturn;    private boolean poolPreparedStatements;    private int maxPoolPreparedStatementPerConnectionSize;    private long removeAbandonedTimeoutMillis;    private boolean removeAbandoned;    private boolean logAbandoned;    private boolean logDifferentThread;    private String filters;    private String connectionProperties;    private boolean useGlobalDataSourceStat;}</code></pre><p>加载数据源配置文件：</p><pre><code>@Configuration@EnableConfigurationProperties(DruidProperties.class)@ConditionalOnClass({DruidProperties.class})@EnableAutoConfiguration(exclude = DataSourceAutoConfiguration.class) //去除数据源自动配置public class DruidSourceConfigure {    @Autowired    private DruidProperties properties;    private DruidDataSource dataSource;    @Bean    public DataSource dataSource() {        this.dataSource = new DruidDataSource();        this.dataSource.setDriverClassName(properties.getDriverClassName());        this.dataSource.setUrl(properties.getUrl());        this.dataSource.setUsername(properties.getUsername());        if (properties.getUsername() != null) {            this.dataSource.setUsername(properties.getUsername());        }        if (properties.getPassword() != null) {            this.dataSource.setPassword(properties.getPassword());        }        //加载配置        this.dataSource.setInitialSize(properties.getInitialSize());        this.dataSource.setMinIdle(properties.getMinIdle());        this.dataSource.setMaxActive(properties.getMaxActive());        this.dataSource.setMaxWait(properties.getMaxWait());        this.dataSource.setTimeBetweenEvictionRunsMillis(properties.getTimeBetweenEvictionRunsMillis());        this.dataSource.setMinEvictableIdleTimeMillis(properties.getMinEvictableIdleTimeMillis());        this.dataSource.setValidationQuery(properties.getValidationQuery());        this.dataSource.setTestWhileIdle(properties.isTestWhileIdle());        this.dataSource.setTestOnReturn(properties.isTestOnReturn());        this.dataSource.setTestOnBorrow(properties.isTestOnBorrow());        this.dataSource.setPoolPreparedStatements(properties.isPoolPreparedStatements());        this.dataSource.setRemoveAbandoned(properties.isRemoveAbandoned());        this.dataSource.setRemoveAbandonedTimeoutMillis(properties.getRemoveAbandonedTimeoutMillis());        this.dataSource.setMaxPoolPreparedStatementPerConnectionSize(properties.getMaxPoolPreparedStatementPerConnectionSize());        this.dataSource.setLogAbandoned(properties.isLogAbandoned());        this.dataSource.setLogDifferentThread(properties.isLogDifferentThread());        try {            this.dataSource.setFilters(properties.getFilters());        } catch (SQLException e) {            e.printStackTrace();        }        this.dataSource.setUseGlobalDataSourceStat(properties.isUseGlobalDataSourceStat());        this.dataSource.setConnectionProperties(properties.getConnectionProperties());        return dataSource;    }}</code></pre><p>druid监控：</p><pre><code>@Configurationpublic class DruidMoniterConfigure {    /**     * 注册一个StatViewServlet     * @return     */    @Bean    public ServletRegistrationBean druidStatViewServlet(){        //org.springframework.boot.context.embedded.ServletRegistrationBean提供类的进行注册.        ServletRegistrationBean servletRegistrationBean = new ServletRegistrationBean(new StatViewServlet(),&quot;/druid/*&quot;);        //添加初始化参数：initParams        //白名单：        servletRegistrationBean.addInitParameter(&quot;allow&quot;,&quot;127.0.0.1&quot;);        //IP黑名单 (存在共同时，deny优先于allow) : 如果满足deny的话提示:Sorry, you are not permitted to view this page.        servletRegistrationBean.addInitParameter(&quot;deny&quot;,&quot;192.168.1.73&quot;);        //登录查看信息的账号密码.        servletRegistrationBean.addInitParameter(&quot;loginUsername&quot;,&quot;admin&quot;);        servletRegistrationBean.addInitParameter(&quot;loginPassword&quot;,&quot;123456&quot;);        //是否能够重置数据.        servletRegistrationBean.addInitParameter(&quot;resetEnable&quot;,&quot;false&quot;);        return servletRegistrationBean;    }    /**     * 注册一个：filterRegistrationBean     * @return     */    @Bean    public FilterRegistrationBean druidStatFilter(){        FilterRegistrationBean filterRegistrationBean = new FilterRegistrationBean(new WebStatFilter());        //添加过滤规则.        filterRegistrationBean.addUrlPatterns(&quot;/*&quot;);        //添加不需要忽略的格式信息.        filterRegistrationBean.addInitParameter(&quot;exclusions&quot;,&quot;*.js,*.gif,*.jpg,*.png,*.css,*.ico,/druid/*&quot;);        return filterRegistrationBean;    }}</code></pre><hr><h2 id="JDBCTemplate测试"><a href="#JDBCTemplate测试" class="headerlink" title="JDBCTemplate测试"></a>JDBCTemplate测试</h2><p>测试controller:</p><pre><code>@RestController@RequestMapping(&quot;/movie&quot;)public class MovieController {    @Autowired    private MovieService movieService;    @GetMapping(&quot;/list&quot;)    public List&lt;MovieVO&gt; getMovies(){        List&lt;MovieVO&gt; movieVOList=movieService.getMovies();        return movieVOList;    }}</code></pre><p>测试service:</p><pre><code>@Servicepublic class MovieServiceImpl implements MovieService {    @Autowired    private MovieMapper movieMapper;    @Override    public List&lt;MovieVO&gt; getMovies() {        return movieMapper.getMovies();    }}</code></pre><p>测试mapper:</p><pre><code>@Autowired    private JdbcTemplate jdbcTemplate;    public List&lt;MovieVO&gt; getMovies(){        String sql=&quot;select * from tb_movie&quot;;        List&lt;MovieVO&gt; movieVOList = jdbcTemplate.query(sql, new Object[]{}, new BeanPropertyRowMapper&lt;&gt;(MovieVO.class));        if(null!=movieVOList&amp;&amp;movieVOList.size()&gt;0){           return movieVOList;        }else{            return null;        }    }</code></pre>]]></content>
      
      
      <categories>
          
          <category> spring boot </category>
          
          <category> 微服务 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 脚手架 </tag>
            
            <tag> druid </tag>
            
            <tag> jdbcTemplate </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>从零开始搭建spring boot脚手架（二）</title>
      <link href="/2018/12/13/cong-ling-kai-shi-da-jian-spring-boot-jiao-shou-jia-er/"/>
      <url>/2018/12/13/cong-ling-kai-shi-da-jian-spring-boot-jiao-shou-jia-er/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>spring boot相关的配置文件以及自定义配置的读取</p></blockquote><hr><h2 id="自定义配置"><a href="#自定义配置" class="headerlink" title="自定义配置"></a>自定义配置</h2><p>首先在application.yml文件里尝试一发自定义配置：</p><pre><code>my: name: wmy age: 25</code></pre><p>该如何读取这个配置呢？在spring boot中即可通过@Value注解来读取配置文件，试用一下：</p><pre><code> @Value(&quot;${my.name}&quot;)    public String name;    @Value(&quot;${my.age}&quot;)    public String age;    @GetMapping(&quot;/value&quot;)    public Object testValue(){        Map map=new HashMap&lt;&gt;();        map.put(&quot;name&quot;,name);        map.put(&quot;age&quot;,age);        return map;    }</code></pre><p>在浏览器输入相应访问路径：</p><pre><code>{name: &quot;wmy&quot;,age: &quot;25&quot;}</code></pre><p>如果配置过多，为了避免麻烦，我们可以将所有配置封装成一个实体类，这样每次要调用某个配置，我们只需实例化一个该类的对象即可。<br>yml文件配置如下：</p><pre><code>my: name: wmy age: 25 sex: 男 job: 软件工程师</code></pre><p>建立与之对应的实体类（为了省略get,set方法，此处用了lombok)：</p><pre><code>@ConfigurationProperties(prefix = &quot;my&quot;) // 这个注解将配置映射到实体类@Data@Component //不加，注入时显示无法注入，但是还是可以运行public class Person {    private String name;    private String age;    private String sex;    private String job;}</code></pre><p>测试：</p><pre><code>  @Autowired    private Person person;    @GetMapping(&quot;/value&quot;)    public Object testValue(){        Map map=new HashMap&lt;&gt;();        map.put(&quot;name&quot;,person.getName());        map.put(&quot;age&quot;,person.getAge());        map.put(&quot;sex&quot;,person.getSex());        map.put(&quot;job&quot;,person.getJob());        return map;    }</code></pre><p>访问效果：</p><pre><code>{sex: &quot;男&quot;,name: &quot;wmy&quot;,job: &quot;软件工程师&quot;,age: &quot;25&quot;}</code></pre><hr><h2 id="自定义配置文件"><a href="#自定义配置文件" class="headerlink" title="自定义配置文件"></a>自定义配置文件</h2><p>如果配置文件太多，你想单独新建配置文件来放特殊需求的配置也行。<br>在resources下创建配置配置文件test.properties</p><pre><code>com.test.name=wmycom.test.age=26com.test.sex=男com.test.job=软件工程师</code></pre><p>配置实体类：</p><pre><code>@Configuration //或者@Component都可以不加@ConfigurationProperties(prefix = &quot;com.test&quot;) // 这个注解将配置映射到实体类@PropertySource(value = &quot;classpath:test.properties&quot;,encoding = &quot;gbk&quot;) //encoding控制编码@Datapublic class Person {    private String name;    private String age;    private String sex;    private String job;}</code></pre><p>感觉@Configuration就是为了标记这个类为配置类，好像专门拿来标记配置类，大佬可以解释下？<br>百度了一下，@Configuration和@Component还是有很大区别的。以后有时间研究。</p><hr><h2 id="多环境配置文件"><a href="#多环境配置文件" class="headerlink" title="多环境配置文件"></a>多环境配置文件</h2><p> 如果你在相同优先级位置同时有application.properties和application.yml，那么application.yml里面的属性就会覆盖application.properties里的属性。所以，优先推荐使用yml格式的文件</p><p>多环境配置文件一般分为以下几种：</p><pre><code>application-test.yml：测试环境application-dev.yml：开发环境application-prod.yml：生产环境</code></pre><p>需要哪种直接在application.yml配置就行：</p><pre><code>spring:  profiles:    active: dev</code></pre><hr><h2 id="打包"><a href="#打包" class="headerlink" title="打包"></a>打包</h2><ol><li>由于spring boot内置了tomcat，一般打包成了jar包</li></ol><pre><code>java -jar scaffold-0.0.1-SNAPSHOT.jarjava -jar scaffold-0.0.1-SNAPSHOT.jar --server.port=9090 可以用命令改变端口</code></pre><p>运行后，可以访问接口。<br>==打包后发现配置内不加@Configuration或者@Component无法获取配置==</p><ol start="2"><li>打成war需要做的配置（基于2.0以上）</li></ol><pre><code>        &lt;packaging&gt;jar&lt;/packaging&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt;            &lt;scope&gt;provided&lt;/scope&gt;        &lt;/dependency&gt;</code></pre><ol start="3"><li>打包别名设置：</li></ol><pre><code>&lt;build&gt;        &lt;plugins&gt;            &lt;plugin&gt;                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;                &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;            &lt;/plugin&gt;        &lt;/plugins&gt;        &lt;finalName&gt;demo&lt;/finalName&gt; #设置成你想要的名字    &lt;/build&gt;</code></pre>]]></content>
      
      
      <categories>
          
          <category> spring boot </category>
          
          <category> 微服务 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 脚手架 </tag>
            
            <tag> 配置 </tag>
            
            <tag> 打包 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>从零开始搭建spring boot脚手架（一）</title>
      <link href="/2018/12/12/cong-ling-kai-shi-da-jian-spring-boot-jiao-shou-jia-yi/"/>
      <url>/2018/12/12/cong-ling-kai-shi-da-jian-spring-boot-jiao-shou-jia-yi/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>spring boot相关概念先请各位大佬自行百度下，有时间可以发个博客介绍下。</p></blockquote><hr><h2 id="项目构建"><a href="#项目构建" class="headerlink" title="项目构建"></a>项目构建</h2><pre><code>作者用idea开发，idea初始化spring boot项目，一般是最新稳定版。构建过程如下：</code></pre><pre><code>file-&gt;new-&gt;project-&gt;spring initialize-&gt;jdk版本-&gt;maven相关配置-&gt;选取依赖（首先选web,其它可以以后添加）</code></pre><p>   初始化后pom.xml：</p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;    xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;    &lt;parent&gt;        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;        &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;        &lt;version&gt;2.1.1.RELEASE&lt;/version&gt;        &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;    &lt;/parent&gt;    &lt;groupId&gt;com.siteqi.cn&lt;/groupId&gt;    &lt;artifactId&gt;scaffold&lt;/artifactId&gt;    &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;    &lt;name&gt;scaffold&lt;/name&gt;    &lt;description&gt;Demo project for Spring Boot&lt;/description&gt;    &lt;properties&gt;        &lt;java.version&gt;1.8&lt;/java.version&gt;    &lt;/properties&gt;    &lt;dependencies&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;            &lt;scope&gt;test&lt;/scope&gt;        &lt;/dependency&gt;    &lt;/dependencies&gt;    &lt;build&gt;        &lt;plugins&gt;            &lt;plugin&gt;                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;                &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;            &lt;/plugin&gt;        &lt;/plugins&gt;    &lt;/build&gt;&lt;/project&gt;</code></pre><p>初始化后一般生成如下目录：</p><ul><li>main 主要放置项目启动类：项目名+Application eg：ScaffoldApplication。</li><li>test 主要放置项目启动测试类类。</li><li>resource 静态资源 最重要的是application.properties，你可以在这里配置所有配置，也可以用yml格式的配置文件。</li></ul><hr><h2 id="配置测试"><a href="#配置测试" class="headerlink" title="配置测试"></a>配置测试</h2><ol><li>建立一个controller包，创建以下测试类：</li></ol><pre><code>/** * 测试Controller * * @author wangmaoyu * @create 2018-12-12 22:38 **/@RestController@RequestMapping(&quot;/test&quot;)public class TestController {    @GetMapping(&quot;/hello&quot;)    public String hello(){        return &quot;这是我第一个spring boot项目！&quot;;    }}</code></pre><ol start="2"><li>application.yml配置如下：</li></ol><pre><code>server:  port: 8080</code></pre><ol start="3"><li>这样运行ScaffoldApplication启动类，启动成功后即可在浏览器中<a href="http://localhost:8080/test/hello访问接口，浏览器里显示：" target="_blank" rel="noopener">http://localhost:8080/test/hello访问接口，浏览器里显示：</a></li></ol><pre><code>这是我第一个spring boot项目！</code></pre><hr><h2 id="兴趣"><a href="#兴趣" class="headerlink" title="兴趣"></a>兴趣</h2><p>更改启动banner:<br>在resource创建banner.txt,启动后会将banner改为你在txt文件里的内容：<br>我修复改的：</p><pre><code>    _ooOoo_                  o8888888o                  88&quot; . &quot;88                  (| -_- |)                  O\  =  /O               ____/`---&#39;\____             .&#39;  \\|     |//  `.            /  \\|||  :  |||//  \           /  _||||| -:- |||||-  \           |   | \\\  -  /// |   |           | \_|  &#39;&#39;\---/&#39;&#39;  |   |           \  .-\__  `-`  ___/-. /         ___`. .&#39;  /--.--\  `. . __      .&quot;&quot; &#39;&lt;  `.___\_&lt;|&gt;_/___.&#39;  &gt;&#39;&quot;&quot;.     | | :  `- \`.;`\ _ /`;.`/ - ` : | |     \  \ `-.   \_ __\ /__ _/   .-` /  /======`-.____`-.___\_____/___.-`____.-&#39;======                   `=---=&#39;^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^         佛祖保佑       永无BUG</code></pre><blockquote><p>由于工作原因和时间问题，以后可能碰到比较难研究的可能不会在日更。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> spring boot </category>
          
          <category> 微服务 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 脚手架 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>mac下搭建hexo博客</title>
      <link href="/2018/12/11/mac-xia-da-jian-hexo-bo-ke/"/>
      <url>/2018/12/11/mac-xia-da-jian-hexo-bo-ke/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>Hexo，快速、简洁且高效的博客框架Hexo。本身拥有众多的主题，不同的主题可能拥有不同的功能，导航一般都包含有首页，标签，分类，归档，关于等，其它功能基于主题提供者的额外集成相关插件。至于选用什么主题，用户自行百度就好。</p></blockquote><hr><blockquote><p>Hexo貌似使用js搭建的（具体自行百度），作者本身前端能力水平有限就不去讲在Hexo上开发额外功能了。这篇文章主要讲如何在mac下搭建hexo,至于为什么不讲windows上搭建，我还没学会怎么在上面构建node和npm环境。（插一句，mac下开发是真的舒爽，不像微软会出现一大堆莫名奇怪的问题和卡顿。）</p></blockquote><hr><blockquote><p>另外，作者本身是菜鸟，写作不得当处欢迎各位大佬指出，我好及时修正。之所以写博客其实就是想把学习笔记复习下，让自己充分掌握好所学技能，也锻炼下自己的文字表达能力。<br>废话说了一大截，现在开始来操作吧。</p></blockquote><hr><h2 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h2><ol><li>首先检查时候安装了git和node.js（我是用brew安装，这个就自行百度吧）,终端输入一下命令。</li></ol><pre><code>node --v git --version</code></pre><ol start="2"><li>注册github账户，创建仓库，注意仓库名请以用户名命名，这样才能保证你后面能用<br> https://用户名.github.io/  如果要设置域名，需要去购买，域名备案，可以设但没必要，备案麻烦。</li></ol><pre><code>eg: https://x-code01.github.io/ 我的博客地址</code></pre><ol start="3"><li>配置SSH钥匙，保证github的连通性，后面自己的修改才能提交到github上。<pre><code>ssh-keygen -t rsa -C &quot;your_email@example.com&quot; 遇到密码直接跳过cd .ssh然后把id_rsa.pub的内容复制出来贴到github用户setting里面的ssh秘钥即可ssh -T git@github.com 测试是否设置成功</code></pre></li></ol><hr><h2 id="搭建步骤"><a href="#搭建步骤" class="headerlink" title="搭建步骤"></a>搭建步骤</h2><ol><li>安装Hexo</li></ol><pre><code>npm install -g hexonpm install hexo-deployer-git --save #这个东西才能运行部署命令hexo init #初始化，默认landscape的主题</code></pre><ol start="2"><li>hexo配置（_config.yml)</li></ol><pre><code>theme: 主题名 #这里配置主题，注意配置文件：后都有空格，另外需要下载其他主题，在thems目录下 git clone 主题仓库地址即可，除此外还在相应的主题目录下的配置文件的配置，一般主题提供者都会说明。# 配置仓库以及分支：deploy:  type: git #必须用git  repo: git@github.com:x-code01/x-code01.github.io.git #仓库地址  branch: master #分支</code></pre><ol start="3"><li>写博客</li></ol><pre><code>hexo new &quot;博客名&quot; # 会在根目录下的/source/_posts的生成相应的博客名.md文件，用markdown语法修改文件类容即可</code></pre><ol start="4"><li>部署</li></ol><pre><code>hexo clean #清空之前生成的缓存，类似maven cleanhexo g #打包，这个应该都懂hexo d  #同步到你的远程github仓库，就是发布的意思hexo s #发布到本地的4000端口上：localhost:4000即可访问</code></pre><hr><h2 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h2><p>hexo s 本地发布测试访问老是报index.html（这不就是单页面应用吗？)，不要怀疑肯定是某个流程弄错了，仔细检查下就没啥问题了，至于哪些流程问题出错了，我也记不清了（这就是写博客的必要性，老年健忘症）。</p><hr><blockquote><p>可能文章写得不是够清楚明了，这就是第一篇，希望各位大佬和小白们谅解下。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mac </tag>
            
            <tag> 博客 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>对象锁多生产者消费者模式</title>
      <link href="/2018/12/09/dui-xiang-suo-duo-sheng-chan-zhe-xiao-fei-zhe-mo-shi/"/>
      <url>/2018/12/09/dui-xiang-suo-duo-sheng-chan-zhe-xiao-fei-zhe-mo-shi/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="1、烤鸭资源"><a href="#1、烤鸭资源" class="headerlink" title="1、烤鸭资源"></a>1、烤鸭资源</h4><pre><code>package com.ssm.others;import java.util.concurrent.locks.Condition;import java.util.concurrent.locks.Lock;import java.util.concurrent.locks.ReentrantLock;/** * 烤鸭资源 * * @author wangmaoyu * @create 2017-11-14 23:23 **/public class KaoyaResource {    //烤鸭名字    private String name;    //初始数量    private int num=1;    //判断是否需要线程等待的标志    private boolean flag=false;    //创建对象锁    private Lock lock=new ReentrantLock();    //通过已有的锁获取两组监视器，一组监视生产者，一组监视消费者。    Condition producer_con = lock.newCondition();    Condition consumer_con = lock.newCondition();    /**     * 生产烤鸭     * @param name     */    public  void product(String name){        //先获取锁        lock.lock();    try{        while(flag){  //此时有烤鸭需等待            try {                producer_con.await();            } catch (InterruptedException e) {                e.printStackTrace();            }        }        this.name=name+num;        num++;        System.out.println(Thread.currentThread().getName()+&quot;生产了烤鸭&quot;+this.name);        flag=true;//有烤鸭候改变标志       consumer_con.signal();//唤醒消费线程    }finally {        lock.unlock();    }    }    /**     * 消费烤鸭     */    public  void consume(){        lock.lock();        try{            while(!flag){                try {                   consumer_con.await();                } catch (InterruptedException e) {                    e.printStackTrace();                }            }            System.out.println(Thread.currentThread().getName()+&quot;...消费了........&quot;+this.name);//消费烤鸭1            flag = false;            producer_con.signalAll();//通知生产者生产烤鸭        }finally {            lock.unlock();        }    }}</code></pre><hr><h4 id="2、生产者"><a href="#2、生产者" class="headerlink" title="2、生产者"></a>2、生产者</h4><pre><code>package com.ssm.others;/** * 生产者 * * @author wangmaoyu * @create 2017-11-14 23:40 **/public class Producer  implements  Runnable{    private KaoyaResource kaoyaResource;    public Producer(KaoyaResource kaoyaResource) {        this.kaoyaResource = kaoyaResource;    }    @Override    public void run() {        while (true){            kaoyaResource.product(&quot;北京烤鸭&quot;);        }    }}</code></pre><hr><h4 id="3、消费者"><a href="#3、消费者" class="headerlink" title="3、消费者"></a>3、消费者</h4><pre><code>package com.ssm.others;/** * 消费者 * * @author wangmaoyu * @create 2017-11-14 23:42 **/public class Consumer implements  Runnable {    private KaoyaResource kaoyaResource;    public Consumer(KaoyaResource kaoyaResource) {        this.kaoyaResource = kaoyaResource;    }    @Override    public void run() {    while(true){        kaoyaResource.consume();    }    }}</code></pre><hr><h4 id="4、测试"><a href="#4、测试" class="headerlink" title="4、测试"></a>4、测试</h4><pre><code>package com.ssm.others;/** * 测试 * * @author wangmaoyu * @create 2017-11-14 23:38 **/public class Test {    public static void main(String[] args) {        KaoyaResource kaoyaResource=new KaoyaResource();        Producer producer=new Producer(kaoyaResource);        Consumer consumer=new Consumer(kaoyaResource);        Thread t1=new Thread(producer);        Thread t2=new Thread(producer);        Thread t3=new Thread(consumer);        Thread t4=new Thread(consumer);        t1.start();        t2.start();        t3.start();        t4.start();    }}</code></pre><hr>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 消费者模式 </tag>
            
            <tag> 对象锁 </tag>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>CentOS7下Tomcat启动慢的原因及解决方案</title>
      <link href="/2018/12/07/test/"/>
      <url>/2018/12/07/test/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><hr>]]></content>
      
      
      <categories>
          
          <category> 云服务器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> centOS </tag>
            
            <tag> tomcat </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Hello World</title>
      <link href="/2018/12/07/hello-world/"/>
      <url>/2018/12/07/hello-world/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class=" language-bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class=" language-bash"><code class="language-bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class=" language-bash"><code class="language-bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class=" language-bash"><code class="language-bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
  
  
</search>
